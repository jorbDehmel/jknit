/*
Jordan "Jorb" Dehmel
jdehmel@outlook.com
github.com/jorbDehmel
2023 - present
GPLv3 held by author
*/

#include "engine.hpp"

// If defined, clears the jknit folder at the beginning
// Otherwise, clears it at the end of running
// #define DEBUG

bool debug = false, failWithCode = false;

unsigned long long int systemWaitMS = 0;
void smartSys(const string &Command, ostream &Stream)
{
    Stream << "Calling command `" << Command << "`\n";

    auto start = chrono::high_resolution_clock::now();
    int result = system(Command.c_str());
    auto end = chrono::high_resolution_clock::now();
    unsigned long long int ns = chrono::duration_cast<chrono::nanoseconds>(end - start).count();

    Stream << "Command took " << ns << " ns (" << ns / 1'000'000 << " ms)\n";
    systemWaitMS += ns / 1'000'000;

    if (result != 0)
    {
        Stream << "ERROR: Command exited with code " << result << '\n';

        if (failWithCode)
        {
            throw runtime_error("System command failed when 'failWithCode' flag was set.");
        }
    }
    return;
}

Engine::Engine(const bool &DoLog)
{
    doLog = DoLog;

    if (doLog)
    {
        time_t curTime = time(NULL);
        string logPath = "jknit.log";

        cout << "Logging to '" << logPath << "'\n";

        log.open(logPath);
        if (!log.is_open())
        {
            cout << "Failed to open log!\n";
            doLog = false;
        }
        else
        {
            log << "------------------------------------------\n"
                << "Time/date: " << ctime(&curTime)
                << "------------------------------------------\n\n";
        }
    }

    return;
}

Engine::~Engine()
{
    if (log.is_open())
    {
        log.close();
    }
    return;
}

// Input: Compatable file
// Output: .tex file
void Engine::processFile(const string &InputFilepath, const string &OutputFilepath, const bool &PresMode)
{
    bool pres = PresMode;

    if (debug)
    {
        smartSys(rm + buildSpace, log);
    }

    if (doLog)
    {
        log << "Compiling from '" << InputFilepath << "' to \'" << OutputFilepath << "'\n";
    }

    // Open files
    ifstream inputFile(InputFilepath);

    if (!inputFile.is_open())
    {
        throw runtime_error("Could not open input file. Ensure it exists.");
    }

    ofstream output(OutputFilepath);

    if (!output.is_open())
    {
        throw runtime_error("Could not open output file. Ensure it is within an existing folder.");
    }

    // Insert attribution tag
    time_t knitTime = time(NULL);

    output << "% Generated by jknit version " << VERSION << '\n'
           << "% Jordan 'Jorb' Dehmel, jdehmel@outlook.com\n"
           << "% Protected by GPLv3\n"
           << "% github.com/jorbDehmel/jknit\n"
           << "% Knit time: " << ctime(&knitTime) << '\n';

    // Insert standard header
    for (auto line : latexHeader)
    {
        output << line << '\n';
    }

    if (pres)
    {
        output << "\\begin{pres}\n"
               << "\\titleslide{}\n"
               << "\\pagestyle{empty}\n";
    }

    // Do code pass

    if (log.is_open())
    {
        log << "\n------------------------------------------\n"
            << "Code pass: Getting code output\n"
            << "------------------------------------------\n\n";
    }

    string line;
    string all;
    while (!inputFile.eof())
    {
        getline(inputFile, line);
        all += line + '\n';
    }
    inputFile.close();

    buildAllChunks(all);

    if (log.is_open())
    {
        log << "\n------------------------------------------\n"
            << "Compilation pass: Knitting\n"
            << "------------------------------------------\n\n";
    }

    bool prevWasHeader = false;
    stringstream input(all);
    string prevLine;
    while (!input.eof())
    {
        prevLine = line;
        getline(input, line);

        if (line == "")
        {
            // This newline makes for prettier .tex docs
            output << '\n';
            continue;
        }

        // Strip leading whitespace
        while (!line.empty() && (line[0] == ' ' || line[0] == '\t' || line[0] == '\n'))
        {
            line = line.erase(0, 1);
        }

        // Code chunk
        if (line.size() > 3 && line.substr(0, 3) == "```")
        {
            prevWasHeader = false;

            bool lone = line.find("*") != string::npos;
            bool doOutput = line.find("^") == string::npos;
            bool skip = line.find("~") != string::npos;

            // Get header
            if (line.size() <= 5)
            {
                cout << tags::red_bold
                     << "Error: Invalid code chunk header\n"
                     << tags::reset;

                if (doLog)
                {
                    log << "Error: Invalid code chunk header\n";
                }

                continue;
            }

            string header = line.substr(4, line.size() - 5);
            while (!header.empty() && header.back() == '}')
            {
                header.pop_back();
            }

            if (doLog)
            {
                log << "Got header '" << header << "'\n";
            }

            // Get contents
            string contents;
            do
            {
                getline(input, line, '\n');
                if (line.size() < 3 || line.substr(0, 3) != "```")
                {
                    contents += line + '\n';
                }
            } while (!input.eof() && (line.size() < 3 || line.substr(0, 3) != "```"));

            if (header == "settings")
            {
                fromString(contents);
                continue;
            }

            string name;
            for (unsigned int i = 0; i < header.size() && header[i] != ' ' && header[i] != '}'; i++)
            {
                name += header[i];
            }

            if (!skip)
            {
                // Special line
                string lang;
                lang += toupper(name[0]);
                for (int i = 1; i < name.size(); i++)
                {
                    if (string("*~^`{}").find(name[i]) == string::npos)
                    {
                        lang += name[i];
                    }
                }

                // If a recognized language
                if (lstSupportedLangs.count(lang) != 0)
                {
                    output << "\\lstset{language=" << lang << "}\n";
                }
                else
                {
                    lang[0] = tolower(lang[0]);
                    if (lstSupportedLangs.count(lang) != 0)
                    {
                        output << "\\lstset{language=" << lang << "}\n";
                    }
                    else
                    {
                        output << "\\lstset{language=C++}\n";
                    }
                }

                // Otherwise, use C++ (it's a pretty good standard thru listings in latex)

                for (auto l : startCode)
                {
                    output << l << '\n';
                }
                output << contents;
                for (auto l : endCode)
                {
                    output << l << '\n';
                }
            }

            // Run replacement
            if (!doOutput)
            {
                if (doLog)
                {
                    log << "Chunk marked as having no output (^). Skipping.\n";
                }
            }
            else if (skip)
            {
                if (doLog)
                {
                    log << "Skipping chunk.\n";
                }
            }
            else if (lone)
            {
                if (doLog)
                {
                    log << "Lone star chunk! Compiling now.\n";
                }

                stringstream into;
                processChunk(header, contents, into);

                if (into.str() != "")
                {
                    for (auto l : startOutput)
                    {
                        output << l << '\n';
                    }
                    output << into.str();
                    for (auto l : endOutput)
                    {
                        output << l << '\n';
                    }
                }
            }
            else if (chunkOutputs.count(name) != 0 && chunkOutputs[name].size() > (unsigned int)curChunkByLang[name] && chunkOutputs[name][curChunkByLang[name]] != "")
            {
                for (auto l : startOutput)
                {
                    output << l << '\n';
                }

                output << chunkOutputs[name][curChunkByLang[name]];

                for (auto l : endOutput)
                {
                    output << l << '\n';
                }

                curChunkByLang[name]++;
            }
            else
            {
                log << "ERROR: No accompanying chunk!\n";
                curChunkByLang[name]++;
            }
        }

        // Math chunk
        else if (line.size() >= 2 && line.substr(0, 2) == "$$")
        {
            prevWasHeader = false;

            for (auto l : startMath)
            {
                output << l << '\n';
            }

            // Get contents (raw latex)
            do
            {
                getline(input, line);

                // Strip leading whitespace
                while (!line.empty() && (line[0] == ' ' || line[0] == '\t' || line[0] == '\n'))
                {
                    line = line.erase(0, 1);
                }

                if (line.size() < 2 || line.substr(0, 2) != "$$")
                {
                    output << line << '\n';
                }
            } while (!input.eof() && (line.size() < 2 || line.substr(0, 2) != "$$"));

            for (auto l : endMath)
            {
                output << l << '\n';
            }
        }

        // Regular LaTeX or markdown
        else
        {
            // For list parsing
            string listChars = "-:;.,)]";

            // > blockquote
            // \blockquote{}
            if (line[0] == '>')
            {
                prevWasHeader = false;
                output << "\\begin{displayquote}\n"
                       << line.substr(1)
                       << "\n\\end{displayquote}\n";
                continue;
            }

            // --- horizontal line
            // \hrule
            else if (line.substr(0, 2) == "--" || line.substr(0, 2) == "~~" || line.substr(0, 2) == "__" || line.substr(0, 2) == "==")
            {
                prevWasHeader = false;

                // Jump over if rmd header thing
                if (line == "---")
                {
                    do
                    {
                        getline(input, line);
                    } while (line != "---");
                }
                else
                {
                    // Pres handling
                    if (pres)
                    {
                        if (prevLine != "")
                        {
                            // Erase previous line (it is header)
                            output.seekp(output.tellp() - (streampos)prevLine.size() - 1);
                        }

                        output << "\\slide{}\n";

                        output << "\\section*{";

                        for (auto l : startHeader)
                        {
                            output << l << ' ';
                        }

                        output << "\\sffamily{";

                        for (auto c : prevLine)
                        {
                            if (specialCharacters.find(c) != string::npos)
                            {
                                output << "\\verb|" << c << "|";
                            }
                            else
                            {
                                output << c;
                            }
                        }
                        output << "}\\nopunct}~\n";

                        for (auto l : endHeader)
                        {
                            output << l << ' ';
                        }

                        output << "\\bigskip{}\n";

                        prevWasHeader = true;

                        // Skip all the following non-empty lines (settings in rpres)
                        do
                        {
                            prevLine = line;
                            getline(input, line);
                            while (line[0] == ' ' || line[0] == '\t' || line[0] == '\n')
                            {
                                line = line.substr(1);
                            }
                            while (line.back() == ' ' || line.back() == '\t' || line.back() == '\n')
                            {
                                line.pop_back();
                            }
                        } while (line != "");

                        continue;
                    }
                    else
                    {
                        output << "\\hrule{}\n";
                    }
                }
                continue;
            }

            // # ## ### #### headings
            // \section{} \subsection{} \subsubsection{} etc
            else if (line[0] == '#')
            {
                // # => \section{}
                // ## => \subsection{}
                // ### => \subsubsection{}
                // #### => \paragraph{}
                // #####+ => \subparagraph{}

                if (!prevWasHeader)
                {
                    output << "\\bigskip{}\n";
                }

                int numHashes = 0;
                while (line[numHashes] == '#')
                {
                    numHashes++;
                }

                switch (numHashes)
                {
                case 1:
                    output << "\\section*{";
                    break;
                case 2:
                    output << "\\subsection*{";
                    break;
                case 3:
                    output << "\\subsubsection*{";
                    break;
                case 4:
                    output << "\\paragraph*{";
                    break;
                default:
                    output << "\\subparagraph*{";
                    break;
                };

                for (auto l : startHeader)
                {
                    output << l << ' ';
                }

                output << "\\sffamily{";
                processMDLine(line.substr(numHashes), output);
                output << "}\\nopunct}~\n";

                for (auto l : endHeader)
                {
                    output << l << ' ';
                }

                output << "\\bigskip{}\n";

                prevWasHeader = true;
                continue;
            }

            // Ordered / enumerated list
            else if ((line[0] == '1' || line[0] == 'a' || line[0] == 'A') && listChars.find(line[1]) != string::npos)
            {
                prevWasHeader = false;
                output << "\\begin{enumerate}\n";

                // Erase until first space
                while (line.size() > 0 && line[0] != ' ')
                {
                    line.erase(0, 1);
                }

                do
                {
                    output << "\\item{";

                    processMDLine(line, output);

                    output << "}\n";

                    getline(input, line);
                    while (line.size() > 0 && line[0] != ' ')
                    {
                        line.erase(0, 1);
                    }
                } while (!input.eof() && line != "");

                output << "\\end{enumerate}\n";

                continue;
            }

            // Unordered list
            else if (listChars.find(line[0]) != string::npos)
            {
                prevWasHeader = false;
                output << "\n\\begin{itemize}\n";

                while (line.size() > 0 && listChars.find(line[0]) != string::npos)
                {
                    // Strip beginning
                    while (line.size() > 0 && listChars.find(line[0]) != string::npos)
                    {
                        line.erase(0, 1);
                    }

                    output << "\\item{";

                    // Catch internal markdown syntax
                    processMDLine(line, output);

                    output << "}\n";

                    getline(input, line);
                }

                output << "\\end{itemize}\n";
                continue;
            }

            // Links [title](https://www.example.com)
            /*
            \usepackage{hyperref}
            \href{link.com}{text}
            */
            else if (line[0] == '[')
            {
                prevWasHeader = false;
                string title, link;

                // Scan until end of title
                unsigned int i = 1;
                while (i < line.size() && line[i] != ']')
                {
                    if (specialCharacters.find(line[i]) != string::npos)
                    {
                        title += string("\\verb|") + line[i] + "|";
                    }
                    else
                    {
                        title += line[i];
                    }
                    i++;
                }

                if (line[i + 1] != '(')
                {
                    for (auto c : line)
                    {
                        if (specialCharacters.find(c) != string::npos)
                        {
                            output << "\\verb|" << c << "|";
                        }
                        else
                        {
                            output << c;
                        }
                    }
                    output << '\n';
                    continue;
                }

                // Scan until end of link
                i += 2;
                while (i < line.size() && line[i] != ')')
                {
                    if (specialCharacters.find(line[i]) != string::npos)
                    {
                        line += string("\\verb|") + line[i] + "|";
                    }
                    else
                    {
                        link += line[i];
                    }
                    i++;
                }

                // Write latex
                output << "\\href{" << link << "}{";

                // Catch any internal markdown syntax
                processMDLine(title, output);

                output << "}\n";

                continue;
            }

            // Handle markdown image syntax
            else if (line[0] == '!')
            {
                prevWasHeader = false;
                string alt, path, options;

                // Parse caption, path and options
                unsigned int i = 2;
                while (i < line.size() && line[i] != ']')
                {
                    if (specialCharacters.find(line[i]) != string::npos)
                    {
                        alt += string("\\verb|") + line[i] + "|";
                    }
                    else
                    {
                        alt += line[i];
                    }
                    i++;
                }
                i += 2;
                while (i < line.size() && line[i] != ')')
                {
                    if (specialCharacters.find(line[i]) != string::npos)
                    {
                        path += string("\\verb|") + line[i] + "|";
                    }
                    else
                    {
                        path += line[i];
                    }
                    i++;
                }
                i += 2;
                while (i < line.size() && line[i] != '}')
                {
                    // Percentage parsing
                    if (line[i] >= '0' && line[i] <= '9')
                    {
                        string num = "00";
                        while (i < line.size() && line[i] >= '0' && line[i] <= '9')
                        {
                            num += line[i];
                            i++;
                        }

                        if (i < line.size() && line[i] == '%')
                        {
                            num = num.substr(0, num.size() - 2) + "." + num.substr(num.size() - 2);
                            options += num + "\\textwidth ";
                            i++;
                        }
                        else
                        {
                            options += num;
                        }
                    }

                    // Avoid issues with commenting
                    if (i < line.size() && line[i] != '%' && line[i] != '}')
                    {
                        options += line[i];
                    }
                    i++;
                }

                // Convert to latex
                output << "\\begin{figure}[h]\n"
                       << "\\centering\n"
                       << "\\includegraphics[" << options << "]{" << path << "}\n"
                       << "\\caption {";

                // Catches any markdown syntax in captions
                processMDLine(alt, output);

                output << "}\n"
                       << "\\end {figure}\n";

                continue;
            }

            else if (line[0] == '%')
            {
                continue;
            }

            else
            {
                prevWasHeader = false;
                processMDLine(line, output);
            }
        }
    }

    if (pres)
    {
        output << "\\end{pres}\n";
    }

    for (auto l : latexFooter)
    {
        output << l << '\n';
    }

    output.close();

    if (log.is_open())
    {
        log << "\n------------------------------------------\n"
            << "Done.\n"
            << "------------------------------------------\n";
    }

    if (!debug)
    {
        // Clear build folder
        smartSys(rm + buildSpace, log);
    }

    return;
}

void Engine::processChunk(const string Header, const string &Contents, ostream &Stream)
{
    // Parse header to select the correct builder
    string name, options;
    unsigned int i;
    for (i = 0; i < Header.size() && Header[i] != ' '; i++)
    {
        name += Header[i];
    }

    if (i + 1 < Header.size())
    {
        options = Header.substr(i + 1);
    }

    if (doLog)
    {
        log << "Parsed chunk header. Name: '" << name << "' options: '" << options << "'\n";
    }

    // Safety check
    if (builders.count(name) == 0 || builders[name].commandPath == "")
    {
        if (doLog)
        {
            log << "Processing pathless name '" << name << "' (using name as command)\n";
        }

        builder toAdd;
        toAdd.commandPath = name;
        toAdd.printChunkBreak = "";
        builders[name] = toAdd;
    }

    // Construct appropriate temp file name
    string srcfile = buildSpace + name + "_src_" + to_string(time(NULL)) + "." + builders[name].extension;
    string tempfile = buildSpace + name + "_out_" + to_string(time(NULL)) + ".txt";

    const string illegalNameCharacters = "*^~`";
    for (unsigned int i = 0; i < srcfile.size(); i++)
    {
        if (illegalNameCharacters.find(srcfile[i]) != string::npos)
        {
            srcfile.erase(i, 1);
            i--;
        }
    }
    for (unsigned int i = 0; i < tempfile.size(); i++)
    {
        if (illegalNameCharacters.find(tempfile[i]) != string::npos)
        {
            tempfile.erase(i, 1);
            i--;
        }
    }

    // Send our chunk contents to a file
    smartSys(mkdir + buildSpace, log);

    if (doLog)
    {
        log << "Saving chunk source code to file '" << srcfile << "'\n";
    }

    ofstream output(srcfile);

    if (!output.is_open())
    {
        throw runtime_error("Failed to open file for code output saving.");
    }

    output << Contents;
    output.close();

    // Compile and send output to our temp file
    // Already system-independent, so long as filenames are formatted right
    smartSys(builders[name].commandPath + " " + srcfile + " > " + tempfile, log);

    // Load output temp file into string
    if (doLog)
    {
        log << "Loading output from file '" << tempfile << "'\n";
    }
    string line;
    ifstream input(tempfile);

    if (!input.is_open())
    {
        throw runtime_error("Could not load code chunk output.");
    }

    while (!input.eof())
    {
        getline(input, line);
        Stream << ">> " << line << '\n';
    }

    input.close();

    if (doLog)
    {
        log << "Done!\n";
    }

    return;
}

void Engine::setPath(const string &Name, const string &Path)
{
    builder toAdd;
    toAdd.commandPath = Path;
    builders[Name] = toAdd;
    return;
}

bool Engine::hasPath(const string &What) const
{
    return builders.count(What) != 0;
}

string Engine::toString() const
{
    stringstream out;

    for (auto p : builders)
    {
        out << '"' << p.first << "\": \"" << p.second.commandPath << "\"\n";
    }

    return out.str();
}

string strip(const string &What)
{
    if (What.empty())
    {
        return What;
    }

    string out(What);
    while (out[0] == '\'' || out[0] == '"' || out[0] == ' ' || out[0] == ':' || out[0] == '=')
    {
        out.erase(0, 1);

        if (out.empty())
        {
            return out;
        }
    }

    while (out.back() == '\'' || out.back() == '"' || out.back() == ' ' || out.back() == ':' || out.back() == '=')
    {
        out.erase(out.size() - 1, 1);

        if (out.empty())
        {
            return out;
        }
    }

    return out;
}

void Engine::fromString(const string &From)
{
    if (From.empty())
    {
        throw runtime_error("Cannot load settings from an empty string.");
    }

    // Parse loaders
    // "loader name here": "path here" ".ext" "options here"

    stringstream fromStream(From);
    string name, path, printCall, extension;

    while (!fromStream.eof())
    {
        name = path = printCall = extension = "";
        fromStream >> name;

        // Handle path
        fromStream >> path;
        if (path[0] == '\'' || path[0] == '"')
        {
            string word;
            while (path.back() != path.front())
            {
                fromStream >> word;
                path += ' ' + word;
            }

            path.erase(0, 1);
            path.pop_back();
        }

        // Handle print call
        fromStream >> printCall;
        if (printCall[0] == '\'' || printCall[0] == '"')
        {
            string word;
            while (printCall.back() != printCall.front())
            {
                fromStream >> word;
                printCall += ' ' + word;
            }

            printCall.erase(0, 1);
            printCall.pop_back();
        }

        fromStream >> extension;

        if (name == "" || path == "" || printCall == "")
        {
            break;
        }

        if (extension == "")
        {
            extension = "txt";
        }

        name = strip(name);
        path = strip(path);
        printCall = strip(printCall);
        extension = strip(extension);

        // Add to list of loaders
        builder toAdd;
        toAdd.printChunkBreak = printCall;
        toAdd.commandPath = path;
        toAdd.extension = extension;

        builders[name] = toAdd;

        if (doLog)
        {
            log << "Loaded builder '" << name << "' with path '" << path << "' and chunk break print call '" << printCall << "'\n";
            log << "Builder set size: " << builders.size() << '\n';
        }

        fromStream.ignore(128, '\n');
    }

    return;
}

void Engine::toStream(ostream &Stream) const
{
    Stream << toString();
    return;
}

void Engine::processMDLine(const string &Line, ostream &output)
{
    string line = Line;

    // Iterate through full text
    for (unsigned int i = 0; i < line.size(); i++)
    {
        // Escape character
        if (line[i] == '\\')
        {
            // If * or `, don't print backslash literals
            if (i + 1 < line.size() && line[i + 1] != '`' && line[i + 1] != '*')
            {
                output << '\\';
            }
            i++;
            output << line[i];
        }

        // Inline math literal
        else if (line[i] == '$')
        {
            do
            {
                output << line[i];
                i++;
            } while (i < line.size() && line[i] != '$');
            output << "$";
        }

        // Latex reserved characters
        else if (specialCharacters.find(line[i]) != string::npos)
        {
            output << "\\verb|" << line[i] << "|";
        }

        // `code`
        // \verb||
        else if (line[i] == '`')
        {
            output << "\\verb|";

            i++;
            while (i < line.size() && line[i] != '`')
            {
                output << line[i];
                i++;
            }
            output << "|";
        }

        // *italicized*
        // \emph{}
        else if (i < line.size() && line[i] == '*')
        {
            i++;

            // **bold**
            // \textbf{}
            if (i < line.size() && line[i] == '*')
            {
                output << "\\textbf{";

                i++;
                while (line.substr(i, 2) != "**")
                {
                    if (specialCharacters.find(line[i]) != string::npos)
                    {
                        output << "\\verb|" << line[i] << "|";
                    }
                    else
                    {
                        output << line[i];
                    }
                    i++;
                }
                i++;

                output << "}";
            }
            else
            {
                output << "\\emph{";

                while (i < line.size() && line[i] != '*')
                {
                    if (specialCharacters.find(line[i]) != string::npos)
                    {
                        output << "\\verb|" << line[i] << "|";
                    }
                    else
                    {
                        output << line[i];
                    }
                    i++;
                }

                output << "}";
            }
        }

        else
        {
            output << line[i];
        }
    }

    output << '\n';
}

void Engine::buildAllChunks(const string &FileContents)
{
    // code[name] = pair<string, string>(header, contents);
    map<string, pair<string, string>> code;
    stringstream input(FileContents);

    const string stripChars = " \t";

    // Scan chunks, collate
    //      Iterate over lines
    string line;
    while (!input.eof())
    {
        getline(input, line);

        // Strip line
        while (!line.empty() && stripChars.find(line[0]) != string::npos)
        {
            line.erase(0, 1);
        }

        // If line starts with ```
        if (line.size() > 3 && line.substr(0, 3) == "```")
        {
            bool lone = line.find("*") != string::npos;
            bool doBreakLine = line.find("^") == string::npos;
            bool skip = line.find("~") != string::npos;

            string header = line.substr(4, line.size() - 5);
            while (header.back() == '}' || header.back() == '*' || header.back() == '^')
            {
                header.pop_back();
            }

            string contents;
            string name;

            unsigned int i;
            for (i = 0; i < header.size() && header[i] != ',' && header[i] != '}'; i++)
            {
                name += header[i];
            }

            // Collect contents
            do
            {
                getline(input, line);
                string toAdd = line;

                // Strip for scanning
                while (!line.empty() && stripChars.find(line[0]) != string::npos)
                {
                    line.erase(0, 1);
                }

                // Add if this is not a terminal line
                if (line.size() < 3 || line.substr(0, 3) != "```")
                {
                    contents += toAdd + '\n';
                }
            } while (line.size() < 3 || line.substr(0, 3) != "```");

            if (header == "settings")
            {
                fromString(contents);
                continue;
            }

            // Nullification character
            else if (lone)
            {
                if (doLog)
                {
                    log << "Lone star chunk! Kicking compilation to parse-time.\n";
                }
                continue;
            }
            else if (skip)
            {
                if (doLog)
                {
                    log << "Skipping chunk.\n";
                }
                continue;
            }

            else if (doBreakLine && builders.count(name) != 0 && builders[name].printChunkBreak != "")
            {
                contents += builders[name].printChunkBreak + "\n\n";
            }
            else if (doBreakLine)
            {
                cout << "WARNING: Print is not known for language '" << name << "'\n";
                contents += "CHUNK_PARSE_ERROR\n";
            }
            else
            {
                if (doLog)
                {
                    log << "Chunk is marked as outputless (^ operator)\n";
                }
            }

            // Append to code of similar type
            if (code.count(name) == 0)
            {
                code[name] = pair<string, string>(header, contents);
            }
            else
            {
                code[name].second += contents;
            }
        }
    }

    if (doLog)
    {
        log << "Getting code output...\n";
    }

    // Get outputs for each type of code
    map<string, string> outputs;
    for (auto p : code)
    {
        stringstream chunk;

        // Read the output of the chunk into the chunk string stream
        processChunk(p.second.first, p.second.second, chunk);

        // Log the output in outputs
        outputs[p.first] = chunk.str();
    }

    if (doLog)
    {
        log << "Splitting outputs\n";
    }

    // Split along chunk-split printings for each output type
    for (auto output : outputs)
    {
        // output.first = name
        // output.second = output
        // Parse output by lines which contain "CHUNK_BREAK"
        stringstream chunk(outputs[output.first]);

        if (doLog)
        {
            log << "FULL OUTPUT:\n"
                << chunk.str() << '\n';
        }

        string currentChunk, line;
        do
        {
            getline(chunk, line);

            if (doLog)
            {
                log << "LINE:\n"
                    << line << '\n';
            }

            if (line.find("CHUNK_BREAK") == string::npos)
            {
                currentChunk += line + '\n';
            }
            else
            {
                chunkOutputs[output.first].push_back(currentChunk);

                if (doLog)
                {
                    log << "CHUNK:\n"
                        << currentChunk << '\n'
                        << "END CHUNK\n";
                }

                currentChunk.clear();
            }
        } while (!chunk.eof());

        // Strip newlines
        while (!currentChunk.empty() && currentChunk.front() == '\n')
        {
            currentChunk.erase(0, 1);
        }
        while (!currentChunk.empty() && currentChunk.back() == '\n')
        {
            currentChunk.pop_back();
        }

        chunkOutputs[output.first].push_back(currentChunk);
        currentChunk.clear();

        if (doLog)
        {
            log << "CHUNK:\n"
                << currentChunk << '\n'
                << "END CHUNK\n";

            log << "File type '" << output.first << "' has " << chunkOutputs[output.first].size() << " output chunks.\n";
        }

        curChunkByLang[output.first] = 0;
    }

    if (doLog)
    {
        log << "Done.\n";
    }

    return;
}
